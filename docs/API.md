# OpenGuild Client API (Skeleton)

This document will capture the REST and WebSocket contracts exposed by the homeserver.

## Planned Sections

1. Authentication & session lifecycle
2. Guild and channel management endpoints
3. Messaging and reactions
4. Media upload and retrieval
5. Voice signaling
6. Bot and webhook integration

Populate each section as the implementation progresses.

## Implemented (bootstrap)

- `GET /health` - liveness probe, returns `ok`.
- `GET /ready` - readiness probe, returns status, uptime and component list.
- `GET /version` - returns `{ "version": "<semver>" }` from package metadata.
- `POST /sessions/login` - issues a signed session token when credentials validate.

### Response Headers

- Every HTTP response includes an `X-Request-Id` header. If the client supplies one it is echoed back; otherwise the server generates a UUIDv4 so logs, metrics, and client traces can be correlated.

## Authentication & Session Lifecycle

### `POST /sessions/login`

Initiates a session for the supplied identifier/secret pair. The current prototype authenticates against an in-memory store (suitable for local development); issued sessions persist to Postgres when a database pool is available (see `backend/migrations/0002_create_sessions.sql`), otherwise they remain in-memory for the process lifetime.

- **Success**: returns HTTP 200 with a JSON payload containing a signed token and expiration timestamp.
- **Validation error**: returns HTTP 400 with a list of field errors.
- **Invalid credentials**: returns HTTP 401 with `{"error":"invalid_credentials"}`.

#### Request Body

```json
{
  "identifier": "alice@example.org",
  "secret": "supersecret"
}
```

#### Successful Response

```json
{
  "token": "eyJzZXNzaW9uX2lkIjoiYmI4NzJiZjAt...snip...SzM1MjQifQ.7QAuPNJxjZO2q6WmyRjGy_qKSLqoTj_xdG9aQa2bjRw",
  "expires_at": "2025-10-12T21:34:26.123456Z"
}
```

> Token and timestamp above are illustrative. The actual value encodes the session payload (base64url) followed by an ed25519 signature.

#### Validation Error (HTTP 400)

```json
{
  "error": "validation_error",
  "details": [
    { "field": "identifier", "message": "must be provided" },
    { "field": "secret", "message": "must be provided" }
  ]
}
```

#### Invalid Credentials (HTTP 401)

```json
{
  "error": "invalid_credentials"
}
```

#### Quick Test (curl)

```bash
curl -X POST http://127.0.0.1:8080/sessions/login \
  -H "content-type: application/json" \
  -d '{"identifier":"alice@example.org","secret":"supersecret"}'
```

> When `DATABASE_URL` (or `OPENGUILD_SERVER__DATABASE_URL`) is set, the server will upsert each issued session into the `sessions` table in addition to returning the signed token.

## Guilds & Channels (Week 4 bootstrap)

### `POST /guilds`

Creates a new guild with a human-readable name. Returns HTTP 200 with the created guild record.

```json
{
  "guild_id": "f0b6ebd0-9e1b-4d67-8b66-08bf5b84b0e1",
  "name": "Example Guild",
  "created_at": "2025-10-12T23:59:04.315409Z"
}
```

- **Validation**: `name` must be non-empty (HTTP 400 on failure).

### `GET /guilds`

Lists all guilds known to the server, ordered by creation time.

```json
[
  {
    "guild_id": "f0b6ebd0-9e1b-4d67-8b66-08bf5b84b0e1",
    "name": "Example Guild",
    "created_at": "2025-10-12T23:59:04.315409Z"
  }
]
```

### `POST /guilds/{guild_id}/channels`

Creates a channel within the specified guild.

```json
{
  "channel_id": "3b7f3e93-7c9c-47f5-91d3-cbf09dc5a8f6",
  "guild_id": "f0b6ebd0-9e1b-4d67-8b66-08bf5b84b0e1",
  "name": "general",
  "created_at": "2025-10-12T23:59:07.771025Z"
}
```

- **Validation**: `name` must be non-empty. Attempting to create a channel for a missing guild returns HTTP 404.

### `GET /guilds/{guild_id}/channels`

Lists channels for the guild (HTTP 200, empty array when none exist).
- **Errors**: returns HTTP 404 if the guild ID is unknown.

### `POST /channels/{channel_id}/messages`

Appends an optimistic message event to the channel event log. The route accepts a JSON payload with `sender` and `content` fields. Both fields must be non-empty.

```json
{
  "sender": "@user:example.org",
  "content": "Hello from OpenGuild!"
}
```

Successful requests respond with the sequence number generated by the storage layer:

```json
{
  "sequence": 1,
  "event_id": "$4nTFVwMCeV7zFJmioq5uPyrJ9Wscb1LZ6y3HfHE9mA1S",
  "created_at": "2025-10-12T23:59:12.412457Z"
}
```

Sequences increase monotonically per channel. When a Postgres pool is configured, events are persisted to `channel_events`; otherwise an in-memory journal is used for local development.

- **Errors**: validation failures return HTTP 400; missing channels return HTTP 404.

#### Quick Test (curl)

```bash
CHANNEL_ID=3b7f3e93-7c9c-47f5-91d3-cbf09dc5a8f6
curl -X POST http://127.0.0.1:8080/channels/$CHANNEL_ID/messages \
  -H "content-type: application/json" \
  -d '{"sender":"@user:example.org","content":"hello world"}'
```

## WebSocket Streaming

### `GET /channels/{channel_id}/ws`

Upgrades to a WebSocket that streams channel events to connected clients.

- On connection the server replays the most recent 50 events (oldest to newest) so clients can warm their timeline.
- New events are broadcast fan-out style using a bounded queue (capacity 256 per channel). If a client falls behind, the server closes the socket with close code `POLICY` and a short reason.
- Idle connections must respond to ping/pong frames; writes are timed out after 10 seconds to avoid wedging the broadcast loop.
- A global semaphore caps concurrent connections (currently 256). Excess clients receive HTTP 429 prior to upgrade.
- Requests for unknown channels return HTTP 404 before the handshake completes.

Each WebSocket message is a JSON object shaped as:

```json
{
  "sequence": 42,
  "channel_id": "3b7f3e93-7c9c-47f5-91d3-cbf09dc5a8f6",
  "event": {
    "event_id": "$6kXQ1dTgvYyTF8uZnD8QyUQ9oP3Gvc9nR7fN6vXqBZ3F",
    "event_type": "message",
    "room_id": "3b7f3e93-7c9c-47f5-91d3-cbf09dc5a8f6",
    "sender": "@user:example.org",
    "origin_server": "api.openguild.test",
    "origin_ts": 1749681600000,
    "content": { "content": "hello world" },
    "prev_events": [],
    "auth_events": [],
    "signatures": {}
  }
}
```

The `event` payload is a canonical OpenGuild event (see `openguild-core::event`) and can be fed directly into future federation workflows.
